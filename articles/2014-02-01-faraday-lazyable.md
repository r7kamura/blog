---
title: faraday-lazyable
---

[faraday-lazyable](https://github.com/r7kamura/faraday-lazyable)という、
HTTPリクエストを遅延評価させるためのライブラリを作った。
遅延評価はある種の複雑性を持ち込むが、ビジネスの要求に合わせて正しく使っていきたい。

## 遅延評価
HTTPリクエストにおける遅延評価とは何か。

遅延評価というのは、評価しなければならない値が存在するとき、
実際の計算を値が必要になるまで行わないことをいう。
HTTPリクエストを遅延評価するというのは、つまりHTTPクライアントはすぐにレスポンスオブジェクトを返すが、
レスポンスオブジェクトに対してメソッドが呼ばれたときに初めてHTTP通信を発生させるということを意味している。

## Faraday
Faradayとは何か。

faraday-lazyableは、FaradayというRuby製のHTTPクライアントのプラグインとして実現されている。
FaradayはRackのようにプラグイン(=この分野ではミドルウェアと呼ばれることが多い)を階層構造に配置出来る。
イメージ的には以下の様な感じ。
[(引用元)](http://docs.pylonsproject.org/projects/pylons-webframework/en/latest/concepts.html#wsgi-middleware)

![](/images/2013-11-27-rack-multiplexer/onion.png)

## 使い方
faraday-lazyableを使って遅延評価を実現するにはどうすれば良いか。

```
gem install faraday-lazyable
```

faraday-lazyableはGemパッケージとしてrubygems.orgに登録してあり、上記のようにインストール出来る。
Faradayの使い方と一緒に説明しておこう。
Faradayを利用するには、まずFaraday.newでFaraday::Connectionのインスタンスを作る。
このインスタンスが、いわゆるHTTPクライアントになる。
次に、このインスタンスに対してミドルウェアを登録する。
そして、このインスタンスに対してgetやpost、put等のメソッドを呼ぶと、
HTTPリクエストが送られ、レスポンスオブジェクトを受け取れる。

```ruby
require "faraday-lazyable"

# ここでHTTPクライアントのインスタンスを作りながら、
# 同時に利用するミドルウェアを登録する。
# 今回は、以下の3つのミドルウェアを利用することにする。
#
# 1. 遅延評価を行うミドルウェア
# 2. Net::HTTPを利用してHTTP通信を行うミドルウェア
# 3. HTTP通信が発生したときに標準出力にログを出力するミドルウェア
#
connection = Faraday.new do |connection|
  connection.use Faraday::Lazyable
  connection.adapter :net_http
  connection.response :logger
end

# 通常ならここでGETリクエストが発生するが、
# 今回はFaraday::Lazyableを利用しているので、即時に偽のレスポンスオブジェクトが返る。
response = connection.get("http://example.com")

# レスポンスに対して何らかのメソッドを呼ぶと、
# 初めてここでHTTP通信が発生する。(標準出力がログに出るのを見れば確認できる)
response.status #=> 200
```

## 仕組み
faraday-lazyableはどのような仕組みで実現されているか。

```
module Faraday
  class Lazyable
    def initialize(app)
      @app = app
    end

    def call(env)
      DummyResponse.new { @app.call(env) }
    end
  end
end
```

faraday-lazyableを利用すると、クライアントは実行時に偽のレスポンスオブジェクトを返すようになる。
偽のオブジェクトは何のメソッドも持っていなくて、
何かメソッドが呼ばれるとmethod\_missingを発生させる。
method\_missingは、初回のみHTTP通信を発生させ、全てのメソッド呼び出しをレスポンスオブジェクトに委譲する。

```
module Faraday
  class Lazyable
    class DummyResponse < BasicObject
      instance_methods.each do |method_name|
        undef_method(method_name) unless method_name == :__send__
      end

      def initialize(&block)
        @block = block
      end

      private

      def method_missing(method_name, *args, &block)
        __response__.__send__(method_name, *args, &block)
      end

      def __response__
        @response ||= @block.call
      end
    end
  end
end
```

## キャッシュ
この種の遅延評価はどういう時に便利なのだろうか。

例えば、遅延評価はキャッシュしたいときに便利だと思う。
これから非常に長い文章を以って、
ソフトウェア開発者であれば誰でも意識的に知っていそうなことを言語化しようと試みる。
文章量の割にあまり価値のあることは述べられず、
また何らかの問題に対してはっきりとした答えは出さないので、注意して読むように。

簡単なアプリの例を挙げる。アプリと呼んでいるけどiPhoneアプリでもWebアプリでも何でも構わない。
このアプリでは、システムをModel-View-Controllerの3つの部分に分けて実装するような設計を採用している。
このアプリでは、Controllerでサーバからレシピデータを取得して、
Viewで取得したデータをもとにユーザに表示するUIを生成して画面に表示する。

```
# Controllerの実装
class RecipesController
  def show
    response = client.get("http://example.com/recipes/#{params[:id]}")
    @recipe = Recipe.new(response)
  end

  private

  def client
    Faraday.new
  end
end
```

Controllerでは、サーバに問い合わせてレシピデータを取得した後、
@recipeというインスタンス変数にレシピデータを格納している。
このシステムでは、インスタンス変数に格納したデータがViewに渡され、
Viewが画面表示に必要なデータを生成するという仕組みになっている。

```
<% cache expires_in: 1.hour do %>
  <article class="recipe">
    <h1><%= @recipe.title %></h1>
    <p><%= @recipe.description %></p>
  </article>
<% end %>
```

Viewはこういう感じで、Controllerから渡された@recipeを元にHTMLを生成する。
ここで、ユーザに画面を表示するたびにHTMLを生成するのは無駄が多いから、
パフォーマンスを上げるために生成したHTMLをメモリの中に保存しておいて1時間の間は使い回そうという選択をする
(つまりキャッシュすることにする)。

## 問題を捉える
このコードにどういう問題があるのか。

HTML生成はキャッシュされるようになったが、
ユーザに画面を表示するたびにHTTP通信が発生してしまうという事実がある。
HTTP通信というのはアプリの行う処理の中でもかなり遅い部類に入るもので、
例えば1回の通信で100ms程度掛かったりする。
これはユーザが遅いと体感出来る程度に長い時間なので、
アプリのユーザ体験の品質を向上させるためには何とかしなければならない。

そこで、HTTP通信をキャッシュしようという考えに至る。
HTTP通信をキャッシュする方法には幾つかの選択肢が考えられる。
例えば、Controllerで@recipeを(memcache等の)キャッシュサーバに入れておく方法や、
アプリとサーバの間に(Varnish等の)キャッシュサーバを置く方法、
HTTPクライアントにキャッシュ機構を持たせる方法、
Viewのキャッシュを応用する方法などが考えられる。

さてさて、こういう場合どの方法を選ぶのが良いだろうか。
何を判断基準とするべきだろうか。
そもそも、前述したどの選択肢でもやりたいことは実現できる。
その上で未だに問題になっているのは、いかに複雑性を排除し、変更に強い仕組みに出来るかということだと思う。
つまり、実装コストに見合うバランスで拡張性と保守性を出来る限り向上しましょうということ。

## コンポーネントに分ける
この種の複雑性に直面したときに何を考えれば良いのか。

複雑なものを簡単にするには、小さくて理解しやすい単位に分解する方法が有効であるとされている。
「良い」分け方とは何か。物事の良い分け方の一つとして、「側面」という単位が考えられる。
技術的な側面、業務的な側面など、物事には複数の側面が考えられるので、その側面を単位として分けましょうやということ。

分けた上で、分けた要素をどのように組み立てるかということも重要なので注意したい。
物事は、全体としては意味を持つが、分けて組み立てたところで途端に意味を失ってしまうものが多く、
無闇に分けるだけでは良くないということが経験的に分かっている。
こういう問題に有効な手法として、例えば階層化アーキテクチャというものがある。
ざっくり言うと、目的に応じて層を定義し、各層の中の要素は同じ層か隣接した層としか会話出来ないようにするもの。
例えば、[OSI参照モデル](http://ja.wikipedia.org/wiki/OSI%E5%8F%82%E7%85%A7%E3%83%A2%E3%83%87%E3%83%AB)という例がある。
各層にインターフェースを定義しておき、各層は隣接した層とは必ずそのインターフェースを経由してやりとりする。
これによって何が嬉しいかと言うと、各層において変更が行いやすくなるという点が挙げられる。
ビジネスの要求は変わりやすいという事実が分かっているから、
業務的な側面と技術的な側面を分けておくということは有効であると判断できる。

![](http://dl.dropboxusercontent.com//u/5978869/image/20140201_194503.png)

## 選択する
キャッシュの問題では何を考えて選択すれば良いのか。

1. Controllerで@recipeをmemcache等に入れておく方法
2. アプリとサーバの間にキャッシュサーバを置く方法
3. HTTPクライアントにキャッシュ機構を持たせる方法
4. Viewのキャッシュを応用する方法

1の方法では、技術的な関心と業務的な関心が同じコードの中に編み込まれてしまう危険性がある。
他の方法では、キャッシュに関する関心が業務的な関心とは別の場所で管理でき、
アプリ自体にはほとんど変更を加える必要がない。
2の方法では、管理すべきサーバが増えるのでその分複雑性が増すと言える。
3の方法は、2の方法に比べるとある程度融通が効く。
1〜3の方法ではView用のキャッシュとHTTP用のキャッシュを別々に考えなければならず複雑だったが、
4の方法ではキャッシュと言えばViewのキャッシュだけ考えれば良い。

## Viewのキャッシュを応用する
Viewのキャッシュを応用するにはどうすれば良いか。

別の問題として、Viewのキャッシュを応用するには、遅延評価を行わなければならない。
なぜなら、MVCという構成でViewとControllerを分けてしまっているから。
サーバとの通信はController(もしくはModelで行うという選択肢もあるだろう)で行われてしまうので、
ViewでHTMLを生成するのをキャッシュするより前に既に通信が行われてしまう。
本当は、Controllerの処理では通信を行わず、
Viewでキャッシュを生成することになった時点で初めて通信が行われてほしい。
長かった。ここでようやく、faraday-lazyableが有効に働く機会に巡り合える。
実際のところ、Viewのキャッシュを応用するにはコードの変更はこれだけで済む。
めでたし、めでたし。

```
 def client
-  Faraday.new
+  Faraday.new do |connection|
+    connection.use Faraday::Lazyable
+  end
 end
```

## 複雑性
世界は問題だらけで、問題をある方法で解決すると更に新しい問題が生まれるようになっている。

遅延評価というのは、そもそもシステムに混沌とした複雑性をもたらす。
安易に採用して良いような類のものでは無い。ビジネスの要求に見合ったものかどうかを十分に考えなければならない。
上述した3行の変更に恐ろしい悪魔が潜んでいる。
複雑性とは何ぞやと思われるかもしれないけど、「簡単には分からないことが増える」という風に考えておいたら良いと思う。
例えば、実際にどこでHTTP通信が発生しているかが分からなくなるので、問題が起きたときに原因を突き止めづらくなり、
結果的に障害時の復旧は遅れ、ユーザに大きな迷惑が掛かる、といったことが容易に起こり得る。
なので、(少し強引なまとめ方だが)システムに複雑性を持ち込む時には、
ビジネスの要求に見合ったものかどうかを十分に考えなければならない。

## ビジネスの要求
ビジネスの要求とは何か。

最近のWeb界隈は、スマートフォンの急速な普及にも伴って、
モバイルアプリケーションのようなアプリを沢山作って利益を得ようということに腐心している。
アプリの多くは、サーバとHTTP通信を行いながら動作するようなものが多く、
アプリを沢山作るということは単純に考えるとサーバ側も沢山実装しなければならないということになる。
例えば、iPhoneアプリ用にサーバ側の実装を行って、
成功したので同じサービスのAndroidアプリも作ろうということになって、
そこでまたAndroidアプリ用に新しくサーバ側も実装を行う必要があるというのでは効率が悪い。

そこで、複数のアプリから使えるような汎用的なインターフェースを持ったサーバを実装しようということになって、
HTTP経由でデータ操作を行えるインターフェースを持ったサーバが必要とされる。
この界隈でAPIと呼ばれているものは、こういったインターフェースのことを指すことが多い。
よって、投資対効果を高めるために汎用的なAPIが必要とされている、というビジネスの要求があると言える。
(文脈によって「API」の指す概念が全く異なるので、すごく慎重に言葉を選んでいるつもりだが、それでも誤解は避けられないだろう)

## SOA
SOAとビジネスの関係性とは何か。

最近では、システムを「サービス」という単位で複数に分割し、
それらを協調させて動作させることでシステムを構築しようという流れがある。
これは前述した「側面」によってコンポーネントを分けるというのと同じ考え方で、
ビジネスの要求がサービスごとに急速に変化するので、
サービスという単位で分割することで、
あるサービスへの変更を他のサービスに影響せず行うことを可能とし、
ビジネスの要求をシステムに素早く反映出来るようになることを期待している。

界隈の人達がService-Oriented Architectureと連呼しているのはこういうもののことで、
一方でこれに言及すると他の古参の人達が寄ってきて「SOAに通ずる考え方は昔からあった」
「SOAはもう古い」ということを声高に叫びたがるので、
あまり話題にしたくないものの1つではある。
ああ、心にもなく界隈をDISってしまった。
これから古参が集まってきてソーシャルメディアで厳しいことを言われてしまうんだ。
それもまた一興かもしれない。
ともかく、サービス間の通信には(前述したコンテキストでの)APIを用いることが多いため、
APIはSOAにおいて、ひいては昨今のWeb界隈のビジネスにおいて重要な位置を占めていると言える。

## API納品
システムを開発するとはどういうことなのか。

複雑性を持ち込む際には、要求に見合ったものかどうかを十分に考えなければならないと言った。
大局観を持って考える1つの考え方として、物事のライフサイクルを考えると良いと思う。
そのシステムが、2年で死ぬのか、10年続くのか、どれほどの速さで生きるのか。
生まれてはすぐに死んでいくサービスの1つに過ぎないのか、今後10年の社運が掛かっているようなものなのか、
どれほどの変化を伴うのか、死ぬまでに何人の開発者が携わることになるのか。
そういう考えなしに成功することは難しい。

昔から深遠なものに引かれていて、
昔からそういう知識を見つけては当時好きだった女の子と交換し合うのが好きで、
宇宙工学に憧れていて、東京の大学に行って、
結局宇宙関係の仕事には就けなくて、
深遠なものに近づきたいという気持ちは捨てきれなくて、
情報工学に興味を持って、プログラミングという行為に没頭して、
SEになって、3年で限界が来て仕事を辞めて、
ある日昔好きだった女の子と踏切ですれ違い、
振り向いた後でその人は居ない、という話がある。

宇宙とか、機械工学とか、技術とか、ただ純粋に深遠なものだけを追いかけていたい、という思いで技術者になる人も多いと思う。
ただ、ビジネスの要求を理解することなしに技術だけを適用するということは叶わない。
これについて言えることは、早々に諦めた方がいいということしかない。
諦めて、逃げるか、それでも向き合うか、出来るだけ若いうちに決めた方が、どちらにしろいい結果になる。
勿論、ビジネスの要求を考えることが深遠ではないということでは決してない。
ただ同時に、深淵であるというだけのことだ。

## まとめ
ビジネスの拡大に伴って、世界中至るところで沢山のクライアントアプリがつくられ、APIが作られ、
「我が社もSOAを採用していきましょう」という流れで更に多くのクライアントとAPIが増えていく。
人類はこれからも、ビジネスに合わせて多くのAPIを納品していかなければならない。
faraday-lazyableも、その一助になればと思う。
